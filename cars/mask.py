from scipy import ndimage
import skimage.io as skio
from skimage.color import rgb2gray
from .utils import (
    find_labels_to_process,
    process_label,
    remove_too_small_pix,
    remove_too_small_shape,
)


class CarsMask:
    """Class used to process cars masks generated by a segmentation neural network (Unet)
    by processing satellite imagery.

    Args:
        image (np.ndarray): Color image whith 3 channels on which the segmentation has
        been applied.
        mask (np.ndarray): Mask generated by the segmentation model applied on image.
        Mask is expected to by a grayscale image (2D array), with black (0 value) as
        background and white (255 value) as cars.
    """

    def __init__(self, image, mask):
        self.image = image
        self.imageg = rgb2gray(self.image)
        self.mask = mask
        self.to_split = None
        self.processed_mask = None
        self.processed_labels = None
        self.processed_nlabels = None
        self.labels, self.nlabels = ndimage.label(self.mask)
        print(f"{self.nlabels} labels have been found in mask.")

    def remove_small_objects(self, shape_prod=40, pix=None):
        """Remove labels from mask if those are too small.
        Get cell for each label and if the product of the shape (respectively
        number of pixels/values greater than 0) is more than the shape_prod (respectively
        pix) value consider it as too small and remove. If both shape_prod and pix have a
        value, pix is used.

        Args:
            shape_prod (int, optional): Shape product threshold. Defaults to 40.
            pix (int, optional): Number of pixels, values greater than 0, threshold.
            Defaults to None.
        """
        if pix is not None:
            self.mask = remove_too_small_pix(self.mask, shape_prod)
        elif shape_prod is not None:
            self.mask = remove_too_small_shape(self.mask, shape_prod)
        else:
            print("shape_prod or pix value is needed as threshold.")
        self.labels, self.nlabels = ndimage.label(self.mask)
        print(
            f"{self.nlabels} labels have been found in mask after removing small objects."
        )

    def get_labels_to_split(self, shape_prod=300, pix=None):
        """Find labels who are supposed to contain more than a single car.
        Get cell for each label and if the product of the shape is more
        than the shape_prod value consider it as to process.
        If both shape_prod and pix have a value, shape_prod is used.

        Args:
            shape_prod (int, optional): Shape product threshold. Defaults to 300.
            pix(int, optional): Number of pixels as threshold. Defaults to None.

        Returns:
            List: List of labels too big to contain a single car.
        """
        self.to_split = find_labels_to_process(self.mask, shape_prod, pix)
        print(f"There are {len(self.to_split)} labels to split.")

    def split_labels(self, plot=False):
        """Split labels supposed to contain more than a single car.
        For each label, remove small elements of the cell containing the label of interest,
        apply binary_opening and felzenszwalb as a first step to detach cars. Then, find
        cars orientation, as they are usually parked next to each other, and slide a car mask
        over the mask to find overlapping area as supposed cars.

        Args:
            plot (bool, optional): Control the plot of the different steps. Defaults to False.
        """
        if self.to_split is None:
            print("Get labels to split before trying to split those.")
        elif len(self.to_split) == 0:
            self.processed_mask = self.mask.copy()
            print("There is no labels to split.")
        else:
            d_masks = {}
            for label_id in self.to_split:
                processed_label = process_label(
                    self.image, self.imageg, self.mask, self.labels, label_id, plot
                )
                d_masks[label_id] = processed_label
            # Assemble the original mask with the splitted elements
            processed_mask = self.mask.copy()
            for label_id in d_masks.keys():
                ii, obj_indices = ndimage.find_objects(self.labels)[label_id]
                # Assign white from mask with 255 value
                new = d_masks[label_id].astype(int)
                processed_mask[
                    ii.start : ii.stop, obj_indices.start : obj_indices.stop
                ] = 0
                processed_mask[
                    ii.start : ii.stop, obj_indices.start : obj_indices.stop
                ][new > 0] = 255
            self.processed_mask = processed_mask
            self.processed_labels, self.processed_nlabels = ndimage.label(
                self.processed_mask
            )
            print(f"{self.processed_nlabels} labels have been found in processed_mask.")

    def get_processed_mask(self):
        """Get process mask.

        Returns:
            np.ndarray: Processed mask where 0 is the background and 255 (mostly for saving)
            indicates cars.
        """
        if self.processed_mask is None:
            print("Mask has not been processed yet.")
        return self.processed_mask

    def save_processed_mask(self, save_path):
        if self.processed_mask is None:
            print("Mask has not been procssed yet.")
        else:
            skio.imsave(save_path, self.processed_mask)
